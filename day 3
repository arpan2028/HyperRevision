#Minimum window Substring

"""
Thoughts
This problem is quite hard to solve without running into TLE.
I managed to come up with a TLE solution (passing 165/168 test cases) but will look into the optimized, non-TLE version later. I’m done for today.
I will still paste the solution that i did while Neetcode 75 Challenge. But i still think TLE version provides more value for learning.

It’s a perfect problem for revising Strings, as it requires mastery of three concepts:
	1.	Frequency Matching
	2.	Sliding Window Technique
	3.	Optimization for the Minimum Condition

"""

TLE Version
  
from collections import Counter

class Solution:
    def minWindow(self, s: str, t: str) -> str:
        if not s or not t:
            return ""
        
        need = Counter(t)        # counts of each char in t
        left = 0
        best = (0, float('inf')) # start, end

        def window_matches(L, R):
            # True if s[L:R] contains all chars in t with enough counts
            return Counter(s[L:R]) >= need

        for right in range(1, len(s) + 1):
            # Shrink from the left as long as window is valid
            while window_matches(left, right):
                if right - left < best[1] - best[0]:
                    best = (left, right)
                left += 1

        start, end = best
        return "" if end == float('inf') else s[start:end]

Non- TLE Version(I did earlier in NC 75 Challenge)
class Solution(object):
    def minWindow(self, s, t):
        """
        :type s: str
        :type t: str
        :rtype: str
        """

        # Build freqc dictionary for required character counts
        freqc = {}
        for c in t:
            freqc[c] = freqc.get(c, 0) + 1

        window = {}
        required = len(freqc)  # number of unique chars we need to match
        formed = 0             # number of unique chars matched with required freq

        left = 0
        min_len = float('inf')
        res = ""

        for right in range(len(s)):
            c = s[right]
            window[c] = window.get(c, 0) + 1

            # If current char meets required freq, increment formed
            if c in freqc and window[c] == freqc[c]:
                formed += 1

            # Try to shrink the window while it is valid
            while formed == required:
                # Update result if this window is smaller
                if right - left + 1 < min_len:
                    min_len = right - left + 1
                    res = s[left:right+1]

                # Shrink from the left
                char_left = s[left]
                window[char_left] -= 1
                if char_left in freqc and window[char_left] < freqc[char_left]:
                    formed -= 1

                left += 1

        return res
